// backend/prisma/schema.prisma

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum UserRole {
  provider
  biller
  practice_admin
  platform_admin
}

enum UserStatus {
  ACTIVE
  INVITED
  INACTIVE
}

enum EncounterStatus {
  draft
  ai_suggested
  finalized
  exported
}

enum DenialRiskLevel {
  low
  medium
  high
}

enum ConfidenceBucket {
  low
  medium
  high
}

enum DecisionDelta {
  accepted_as_is
  lower_than_ai
  higher_than_ai
  different_code
}

enum TrainingDifficulty {
  easy
  medium
  hard
}

enum AuditAction {
  AI_SUGGESTED_CODES
  AI_SAFETY
  AI_FEEDBACK
  USER_CHANGED_EM_CODE
  USER_ADDED_DIAGNOSIS
  USER_REMOVED_DIAGNOSIS
  USER_CHANGED_PROCEDURE
  USER_FINALIZED_CODES
  ENCOUNTER_CREATED
  ENCOUNTER_UPDATED
}

// Subscription plan types
enum PlanType {
  starter
  growth
  enterprise
}

// Subscription billing cycle
enum BillingCycle {
  monthly
  annual
}

// Subscription status
enum SubscriptionStatus {
  active
  trialing
  canceled
  past_due
}

// Organization (CustomerAccount) - the legal customer entity
model Organization {
  id                  String         @id @default(uuid())
  name                String
  billingContactName  String?
  billingContactEmail String?
  billingAddress      String?
  practices           Practice[]
  subscriptions       Subscription[]
  createdAt           DateTime       @default(now())
  updatedAt           DateTime       @updatedAt
}

// Subscription captures commercial relationship
model Subscription {
  id               String             @id @default(uuid())
  organization     Organization       @relation(fields: [orgId], references: [id])
  orgId            String
  planType         PlanType           @default(starter)
  billingCycle     BillingCycle       @default(monthly)
  status           SubscriptionStatus @default(active)
  startDate        DateTime           @default(now())
  renewalDate      DateTime?
  // Included limits stored as JSON for flexibility
  includedLimits   Json?              // { maxEncountersPerMonth, maxProviders, maxBillers }
  externalBillingId String?           // Stripe customer/subscription ID (for future)
  createdAt        DateTime           @default(now())
  updatedAt        DateTime           @updatedAt

  @@index([orgId])
}

model Practice {
  id           String        @id @default(uuid())
  name         String
  // Organization relationship
  organization Organization  @relation(fields: [orgId], references: [id])
  orgId        String
  specialty    String?       // primary specialty of the practice
  timeZone     String        @default("America/New_York")
  // Legacy plan fields (kept for backwards compatibility, subscription takes precedence)
  planKey      String        @default("plan_a")
  planSince    DateTime      @default(now())
  users        User[]        // Legacy: direct users via practiceId (for backward compatibility)
  practiceUsers PracticeUser[] // New: users via PracticeUser join table
  encounters   Encounter[]
  auditEvents  AuditEvent[]
  usagePeriods UsagePeriod[]
  configuration PracticeConfiguration?
  userInvites  UserInvite[]
  npsResponses PracticeNpsResponse[]
  // Pilot configuration fields
  pilotLabel             String?
  pilotStartDate         DateTime?
  pilotEndDate           DateTime?
  enabledSpecialtiesJson Json?
  llmModeOverride        String?  // 'mock' | 'openai' | null
  providerCanFinalize    Boolean  @default(true)
  pilotBaselineJson      Json?
  // PHI retention and storage settings
  phiRetentionDays       Int?     // number of days to retain PHI at rest; null means "retain until deleted"
  storePhiAtRest         Boolean  @default(true) // if false, minimize PHI at rest and rely on transient processing
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt

  @@index([orgId])
}

model User {
  id                  String              @id @default(uuid())
  practice            Practice            @relation(fields: [practiceId], references: [id])
  practiceId          String              // Legacy: primary practice (for backward compatibility)
  email               String              @unique // Email is globally unique
  passwordHash        String
  role                UserRole            // Legacy: primary role (for backward compatibility)
  firstName           String
  lastName            String
  isActive            Boolean             @default(true)
  practiceUsers       PracticeUser[]      // New: practice memberships via join table
  encounters          Encounter[]         @relation("EncounterProvider")
  finalizedEncounters Encounter[]         @relation("EncounterFinalizer")
  trainingAttempts    TrainingAttempt[]
  auditEvents         AuditEvent[]
  encounterFeedback   EncounterFeedback[]
  npsResponses        PracticeNpsResponse[]
  preferences         UserPreferences?
  createdAt           DateTime            @default(now())
  updatedAt           DateTime            @updatedAt

  @@unique([practiceId, email]) // Legacy constraint (for backward compatibility)
}

// User preferences for personal settings
// PracticeUser join table: represents membership of a User in a Practice with a specific role
model PracticeUser {
  id          String     @id @default(uuid())
  practice    Practice   @relation(fields: [practiceId], references: [id], onDelete: Cascade)
  practiceId  String
  user        User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId      String
  role        UserRole   // Role scoped per practice
  status      UserStatus @default(ACTIVE)
  createdAt   DateTime   @default(now())

  @@unique([practiceId, userId]) // A user should have at most one membership per practice
  @@index([practiceId])
  @@index([userId])
}

model UserPreferences {
  id              String   @id @default(uuid())
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId          String   @unique
  // General preferences
  theme           String   @default("system") // 'light' | 'dark' | 'system'
  timeZone        String?  // User's preferred timezone
  dateFormat      String   @default("MM/DD/YYYY") // 'MM/DD/YYYY' | 'DD/MM/YYYY'
  // Notification preferences
  notificationPrefs Json?   // { emailAssignments: boolean, emailWeeklySummary: boolean }
  // Role-specific preferences stored as JSON for flexibility
  providerPrefs   Json?    // Provider-specific settings
  billerPrefs     Json?    // Biller-specific settings
  adminPrefs      Json?    // Admin-specific settings
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
}

model Encounter {
  id        String   @id @default(uuid())
  practice  Practice @relation(fields: [practiceId], references: [id])
  practiceId String

  provider   User    @relation("EncounterProvider", fields: [providerId], references: [id])
  providerId String

  finalizedByUser   User?   @relation("EncounterFinalizer", fields: [finalizedByUserId], references: [id])
  finalizedByUserId  String?

  patientPseudoId String
  encounterDate   DateTime
  visitType       String
  specialty       String

  noteText String

  status EncounterStatus @default(draft)

  // AI suggestion fields
  aiEmSuggested            String?
  aiEmAlternativesJson     Json?   // store alternatives as JSON
  aiEmConfidence           Float?
  aiEmLevel                Int?    // numeric level 2-5 derived from code
  aiEmHighestSupportedCode String?
  aiEmHighestSupportedConfidence Float?
  aiEmHighestSupportedLevel Int?   // numeric level for highest supported
  aiDiagnosisSuggestionsJson Json?
  aiProcedureSuggestionsJson Json?
  aiConfidenceBucket       ConfidenceBucket?
  
  // Related diagnosis and procedure records
  diagnosisCodes     EncounterDiagnosis[]
  procedureCodes     EncounterProcedure[]

  // Final codes
  finalEmCode        String?
  finalEmCodeSource  String? // "ai" | "provider" | "biller" | "mixed"
  finalDiagnosisJson Json?   // list of { code, description, source }
  finalProceduresJson Json?  // list of { code, description, modifiers, source }

  // Risk & hints
  denialRiskLevel    DenialRiskLevel?
  denialRiskReasons  Json? // array of strings
  hadUndercodeHint   Boolean @default(false)
  hadMissedServiceHint Boolean @default(false)
  emDecisionDelta    DecisionDelta?

  feedbacks EncounterFeedback[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  finalizedAt DateTime?

  auditEvents AuditEvent[]

  @@index([practiceId, encounterDate])
  @@index([providerId, encounterDate])
  @@index([status])
}

model AuditEvent {
  id          String      @id @default(uuid())
  practice    Practice    @relation(fields: [practiceId], references: [id])
  practiceId  String
  encounter   Encounter   @relation(fields: [encounterId], references: [id])
  encounterId String
  user        User        @relation(fields: [userId], references: [id])
  userId      String
  userRole    UserRole
  action      AuditAction
  payload     Json
  createdAt   DateTime @default(now())

  @@index([practiceId, encounterId])
  @@index([userId, createdAt])
}

model TrainingCase {
  id                     String             @id @default(uuid())
  title                  String
  specialty              String
  difficulty             TrainingDifficulty
  noteText               String
  correctEmCode          String
  correctDiagnosisCodes  Json   // array of strings
  correctProcedureCodes  Json   // array of strings
  attempts               TrainingAttempt[]
  createdAt              DateTime @default(now())
  updatedAt              DateTime @updatedAt
}

model TrainingAttempt {
  id                 String         @id @default(uuid())
  user               User           @relation(fields: [userId], references: [id])
  userId             String
  trainingCase       TrainingCase   @relation(fields: [trainingCaseId], references: [id])
  trainingCaseId     String

  userEmCode         String
  userDiagnosisCodes Json   // array of strings
  userProcedureCodes Json   // array of strings

  aiEmCode           String
  aiDiagnosisCodes   Json   // array of strings
  aiProcedureCodes   Json   // array of strings

  scorePercent       Float
  matchSummary       Json   // { emMatch, diagnosisMatches, ... }

  createdAt          DateTime @default(now())

  @@index([userId, createdAt])
  @@index([trainingCaseId])
}

model LlmEvaluationRun {
  id              String   @id @default(cuid())
  createdAt       DateTime @default(now())
  modelId         String
  caseCount       Int
  emExactRate     Float
  emNearRate      Float
  dxRecall        Float
  procRecall      Float
  avgScorePercent Float
  detailsJson     Json

  @@index([createdAt])
  @@index([modelId])
}

// Usage tracking per practice per billing period
model UsagePeriod {
  id                          String   @id @default(cuid())
  practice                    Practice @relation(fields: [practiceId], references: [id])
  practiceId                  String
  periodStart                 DateTime
  periodEnd                   DateTime
  encountersCreated           Int      @default(0)
  encountersWithAiSuggestions Int      @default(0)
  encountersFinalized         Int      @default(0)
  aiSuggestCalls              Int      @default(0) // Alias for aiCalls
  aiCalls                     Int      @default(0) // Explicit field name
  trainingAttempts            Int      @default(0)
  activeProviders             Int      @default(0)
  createdAt                   DateTime @default(now())
  updatedAt                   DateTime @updatedAt

  @@unique([practiceId, periodStart]) // One usage period per practice per start date
  @@index([practiceId, periodStart, periodEnd])
}

model PracticeConfiguration {
  id                String   @id @default(cuid())
  practice          Practice @relation(fields: [practiceId], references: [id], onDelete: Cascade)
  practiceId        String   @unique
  llmMode           String   @default("mock") // "mock" | "openai" | "anthropic"
  enabledSpecialties Json    @default("[]") // array of specialty strings
  providerCanEditCodes Boolean @default(false) // if true, providers can edit final codes
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
}

model EncounterFeedback {
  id          String    @id @default(cuid())
  encounter   Encounter @relation(fields: [encounterId], references: [id], onDelete: Cascade)
  encounterId String
  user        User      @relation(fields: [userId], references: [id])
  userId      String
  helpful     Boolean
  comment     String?
  createdAt   DateTime  @default(now())

  @@unique([encounterId, userId])
  @@index([encounterId])
  @@index([userId, createdAt])
}

model UserInvite {
  id          String   @id @default(cuid())
  practice    Practice @relation(fields: [practiceId], references: [id])
  practiceId  String
  email       String
  role        UserRole
  token       String   @unique
  expiresAt   DateTime
  acceptedAt  DateTime?
  createdAt   DateTime @default(now())

  @@index([practiceId])
  @@index([token])
}

model PracticeNpsResponse {
  id          String   @id @default(cuid())
  practice    Practice @relation(fields: [practiceId], references: [id])
  practiceId  String
  user        User     @relation(fields: [userId], references: [id])
  userId      String
  score       Int      // 0â€“10
  comment     String?
  createdAt   DateTime @default(now())

  @@index([practiceId, createdAt])
  @@index([userId])
}

// Normalized diagnosis codes for encounters
model EncounterDiagnosis {
  id           String    @id @default(uuid())
  encounter    Encounter @relation(fields: [encounterId], references: [id], onDelete: Cascade)
  encounterId  String
  code         String    // ICD-10 code
  description  String?
  source       String    // 'ai_suggested' | 'final'
  confidence   Float?
  index        Int       // order/position
  createdAt    DateTime  @default(now())

  @@index([encounterId, source])
}

// Normalized procedure codes for encounters
model EncounterProcedure {
  id           String    @id @default(uuid())
  encounter    Encounter @relation(fields: [encounterId], references: [id], onDelete: Cascade)
  encounterId  String
  code         String    // CPT/HCPCS code
  description  String?
  modifiers    String[]  // modifier codes
  source       String    // 'ai_suggested' | 'final'
  confidence   Float?
  index        Int       // order/position
  createdAt    DateTime  @default(now())

  @@index([encounterId, source])
}

